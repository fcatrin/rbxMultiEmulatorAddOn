### Eclipse Workspace Patch 1.0
#P RetroArch_
Index: android/native/jni/input_android.c
===================================================================
--- android/native/jni/input_android.c	(revision 1686)
+++ android/native/jni/input_android.c	(working copy)
@@ -109,7 +109,7 @@
    }
 
    if (debug_enable)
-      snprintf(msg, msg_sizeof, "Pad %d : x = %.2f, y = %.2f, src %d.\n",
+      snprintf(msg, msg_sizeof, "Pada %d : x = %.2f, y = %.2f, src %d.\n",
             state_id, x, y, source);
 }
 
@@ -162,17 +162,30 @@
    if (rtrig > 0.5f)
       *state_cur |= 1ULL << RETRO_DEVICE_ID_JOYPAD_R2;
 
-   if (emulation == ANALOG_DPAD_DUALANALOG)
+   if (emulation == ANALOG_DPAD_DUALANALOG || 1)
    {
       android->analog_state[state_id][0][0] = x * 0x7fff;
       android->analog_state[state_id][0][1] = y * 0x7fff;
       android->analog_state[state_id][1][0] = z * 0x7fff;
       android->analog_state[state_id][1][1] = rz * 0x7fff;
+      android->dpad_emulation[state_id] = ANALOG_DPAD_DUALANALOG;
+
+      android->analog_state[0][0][0] = x * 0x7fff;
+      android->analog_state[0][0][1] = y * 0x7fff;
+      android->analog_state[0][1][0] = z * 0x7fff;
+      android->analog_state[0][1][1] = rz * 0x7fff;
+      android->dpad_emulation[0] = ANALOG_DPAD_DUALANALOG;
+
+      android->analog_state[1][0][0] = x * 0x7fff;
+      android->analog_state[1][0][1] = y * 0x7fff;
+      android->analog_state[1][1][0] = z * 0x7fff;
+      android->analog_state[1][1][1] = rz * 0x7fff;
+      android->dpad_emulation[1] = ANALOG_DPAD_DUALANALOG;
    }
 
    if (debug_enable)
-      snprintf(msg, msg_sizeof, "Pad %d : x %.2f, y %.2f, z %.2f, rz %.2f, src %d.\n",
-            state_id, x, y, z, rz, source);
+      snprintf(msg, msg_sizeof, "Padb %d : x %.2f, y %.2f, z %.2f, rz %.2f, ax %i, ay %i.\n",
+            state_id, x, y, z, rz, android->analog_state[state_id][0][0], android->analog_state[state_id][0][1]);
 }
 
 static bool android_input_use_keycode_lut;
@@ -190,22 +203,28 @@
 
    android->pads_connected = 0;
 
+   RARCH_LOG("pega android_input_use_keycode_lut %s", android_input_use_keycode_lut?"true":"false");
+
    // TODO: rewrite code to not change input binds
    if (!android_input_use_keycode_lut)
    {
       for (j = 0; j < LAST_KEYCODE; j++)
          android_input_keycode_lut[j] = 0;
+      RARCH_LOG("pega  LAST_KEYCODE %i", LAST_KEYCODE);
 
       if (!g_settings.input.autodetect_enable)
       {
+         RARCH_LOG("pega setting maxpads %i", MAX_PADS);
          for (j = 0; j < MAX_PADS; j++)
          {
             uint8_t shift = 8 + (j * 8);
+            RARCH_LOG("pega setting RARCH_FIRST_CUSTOM_BIND %i", RARCH_FIRST_CUSTOM_BIND);
             for (k = 0; k < RARCH_FIRST_CUSTOM_BIND; k++)
             {
+                RARCH_LOG("pega input.binds [%i][%i] valid:%s, joykey:%llu", j, k, g_settings.input.binds[j][k].valid?"true":"false", g_settings.input.binds[j][k].joykey);
                if (g_settings.input.binds[j][k].valid && g_settings.input.binds[j][k].joykey && g_settings.input.binds[j][k].joykey < LAST_KEYCODE)
                {
-                  RARCH_LOG("binding %llu to %d (p%d)\n", g_settings.input.binds[j][k].joykey, k, j);
+                  RARCH_LOG("pega binding %llu to %d (p%d)\n", g_settings.input.binds[j][k].joykey, k, j);
                   android_input_keycode_lut[g_settings.input.binds[j][k].joykey] |= ((k + 1) << shift);
                }
             }
@@ -293,13 +312,36 @@
 int zeus_second_id = -1;
 unsigned zeus_port;
 
+static void android_reset_keys(android_input_t *android, int port) {
+	   unsigned shift = port*8;
+
+	   android->keycode_lut[AKEYCODE_BUTTON_Y]  |= ((RETRO_DEVICE_ID_JOYPAD_Y+1)      << shift);
+	   android->keycode_lut[AKEYCODE_BUTTON_B]  |= ((RETRO_DEVICE_ID_JOYPAD_B+1)      << shift);
+	   android->keycode_lut[AKEYCODE_BUTTON_A]  |= ((RETRO_DEVICE_ID_JOYPAD_A+1)      << shift);
+	   android->keycode_lut[AKEYCODE_BUTTON_X]  |= ((RETRO_DEVICE_ID_JOYPAD_X+1)      << shift);
+	   android->keycode_lut[AKEYCODE_BUTTON_L1]  |= ((RETRO_DEVICE_ID_JOYPAD_L+1)      << shift);
+	   android->keycode_lut[AKEYCODE_BUTTON_R1]  |= ((RETRO_DEVICE_ID_JOYPAD_R+1)      << shift);
+	   android->keycode_lut[AKEYCODE_BUTTON_SELECT]  |= ((RETRO_DEVICE_ID_JOYPAD_SELECT+1) << shift);
+	   android->keycode_lut[AKEYCODE_BUTTON_START]  |= ((RETRO_DEVICE_ID_JOYPAD_START+1)  << shift);
+	   android->keycode_lut[AKEYCODE_DPAD_UP]   |= ((RETRO_DEVICE_ID_JOYPAD_UP+1)     << shift);
+	   android->keycode_lut[AKEYCODE_DPAD_DOWN] |= ((RETRO_DEVICE_ID_JOYPAD_DOWN+1)   << shift);
+	   android->keycode_lut[AKEYCODE_DPAD_LEFT] |= ((RETRO_DEVICE_ID_JOYPAD_LEFT+1)   << shift);
+	   android->keycode_lut[AKEYCODE_DPAD_RIGHT]|= ((RETRO_DEVICE_ID_JOYPAD_RIGHT+1)  << shift);
+	   android->dpad_emulation[port] = ANALOG_DPAD_DUALANALOG;
+	   g_settings.input.libretro_device[port] = RETRO_DEVICE_ANALOG;
+}
+
 static void android_input_set_keybinds(void *data, unsigned device,
       unsigned port, unsigned id, unsigned keybind_action)
 {
    android_input_t *android = (android_input_t*)data;
 
+   RARCH_LOG("android_input_set_keybinds");
+
    if (keybind_action & (1ULL << KEYBINDS_ACTION_SET_DEFAULT_BINDS))
    {
+	   RARCH_LOG("KEYBINDS_ACTION_SET_DEFAULT_BINDS");
+
       /* eight 8-bit values are packed into one uint64_t
        * one for each of the 8 pads */
       unsigned shift = 8 + (port * 8);
@@ -1700,6 +1742,7 @@
 
       android->keycode_lut[AKEYCODE_MENU] |= ((RARCH_MENU_TOGGLE + 1) << shift);
    }
+
 }
 
 // Handle all events. If our activity is in pause state, block until we're unpaused.
@@ -1713,6 +1756,8 @@
    android_input_t *android = (android_input_t*)data;
    *lifecycle_state &= ~lifecycle_mask;
 
+   android_reset_keys(android, 0);
+   android_reset_keys(android, 1);
    while ((ident = ALooper_pollAll((input_key_pressed_func(RARCH_PAUSE_TOGGLE)) ? -1 : 0,
                NULL, NULL, NULL)) >= 0)
    {
@@ -1832,7 +1877,7 @@
                   {
                      if (android->dpad_emulation[state_id] != ANALOG_DPAD_NONE)
                         engine_handle_dpad(android, event, motion_pointer, state_id, msg, sizeof(msg), source, debug_enable,
-                              android->dpad_emulation[state_id]);
+                        		ANALOG_DPAD_DUALANALOG);
                   }
                   else
                   {
@@ -1866,7 +1911,7 @@
                         }
                      }
                      if (debug_enable)
-                        snprintf(msg, sizeof(msg), "Pad %d : x = %.2f, y = %.2f, src %d.\n", state_id, x, y, source);
+                        snprintf(msg, sizeof(msg), "Padx %d : x = %.2f, y = %.2f, src %d.\n", state_id, x, y, source);
                   }
 
                }
@@ -1882,7 +1927,7 @@
                   uint64_t *key = NULL;
 
                   if (debug_enable)
-                     snprintf(msg, sizeof(msg), "Pad %d : %d, ac = %d, src = %d.\n", state_id, keycode, action, source);
+                     snprintf(msg, sizeof(msg), "Pady %d : %d, ac = %d, src = %d.\n", state_id, keycode, action, source);
 
                   if (input_state < (1ULL << RARCH_FIRST_META_KEY))
                      key = &android->pad_state[state_id];
@@ -1899,6 +1944,9 @@
                         *key |= input_state;
                   }
 
+                  if (debug_enable)
+                     snprintf(msg, sizeof(msg), "Padz %d : %d, ac = %d, src = %d, key: %s\n", state_id, keycode, action, source, (key==NULL?"null":"not null"));
+
                   if ((keycode == AKEYCODE_VOLUME_UP || keycode == AKEYCODE_VOLUME_DOWN) && android->keycode_lut[keycode] == 0)
                      handled = 0;
                }
@@ -1941,6 +1989,7 @@
 static int16_t android_input_state(void *data, const struct retro_keybind **binds, unsigned port, unsigned device, unsigned index, unsigned id)
 {
    android_input_t *android = (android_input_t*)data;
+   RARCH_LOG("RETRO_DEVICE_ANALOG device: %i, port:%i, connected:%i, type: %i", device, port, android->pads_connected, g_settings.input.libretro_device[port]);
 
    switch (device)
    {
